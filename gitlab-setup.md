# GitLab Container Registry Setup & Usage

## Getting Started with GitLab Pipelines

GitLab CI/CD allows you to automate the building, testing, and deploying of your application. This automation is defined in a file called `.gitlab-ci.yml` located at the root of your repository.

### Key Concepts

*   **Pipeline**: The top-level component of continuous integration. It comprises a set of jobs executed in stages.
*   **Stage**: A logical grouping of jobs (e.g., `build`, `test`, `deploy`). Jobs in the same stage run in parallel, while stages run sequentially. If a stage fails, the pipeline stops.
*   **Job**: The basic building block. It defines *what* to do (e.g., "compile code", "run tests"). Jobs are executed by **Runners**.
*   **Script**: The shell commands that the runner executes for a specific job.
*   **Runner**: An agent (machine or container) that runs the jobs defined in `.gitlab-ci.yml`. GitLab provides shared runners, or you can host your own.
*   **Artifacts**: Files or directories generated by a job (like a compiled binary or test report) that are saved and passed to subsequent stages.
*   **Variables**: Key-value pairs used to store configuration or secrets (e.g., `CI_REGISTRY`).

### Example Basic Workflow

Here is a simple example of what a `.gitlab-ci.yml` file might look like:

```yaml
stages:
  - build
  - test
  - deploy

build_job:
  stage: build
  script:
    - echo "Compiling the code..."

test_job:
  stage: test
  script:
    - echo "Running unit tests..."

deploy_job:
  stage: deploy
  script:
    - echo "Deploying application..."
```

**How it works:**
1.  **Code Commit**: You push changes to GitLab.
2.  **Pipeline Trigger**: GitLab detects the `.gitlab-ci.yml` and starts a pipeline.
3.  **Build Stage**: `build_job` runs first.
4.  **Test Stage**: If build succeeds, `test_job` runs.
5.  **Deploy Stage**: If tests succeed, `deploy_job` runs.

---

## 1. Enable Container Registry

Ensure the Container Registry is enabled for your project:

1.  Go to your GitLab project.
2.  Navigate to **Settings** > **General**.
3.  Expand **Visibility, project features, permissions**.
4.  Find **Container registry** and ensure the toggle is **On**.
5.  Click **Save changes** if you made any modifications.

## 2. Credentials

GitLab CI/CD automatically provides credentials for the Container Registry during pipeline runs. You generally **do not** need to create manual secrets for basic build-and-push operations within the same project.

### Pipeline Credentials
The `.gitlab-ci.yml` uses these predefined variables:
-   `CI_REGISTRY`: The address of the registry (e.g., `registry.gitlab.com`).
-   `CI_REGISTRY_USER`: The username for the registry.
-   `CI_JOB_TOKEN`: A short-lived token generated for the job, used as the password.

**No manual action is required for pipelines to work.**

### Local Development Credentials
If you want to push or pull images from your local machine:

1.  **Username**: Your GitLab username.
2.  **Password**: You can use your GitLab account password (if 2FA is off) or, recommended, a [Project Access Token](https://docs.gitlab.com/ee/user/project/settings/project_access_tokens.html) or [Personal Access Token](https://docs.gitlab.com/ee/user/profile/personal_access_tokens.html) with `read_registry` and `write_registry` scopes.

**Login Command:**
```bash
docker login registry.gitlab.com -u <username> -p <token>
```
*(Replace `registry.gitlab.com` with your self-hosted GitLab registry URL if applicable)*

## 3. Using Images in Kubernetes

To pull images from your private GitLab Container Registry into a Kubernetes cluster, you need to create a generic `docker-registry` secret and reference it in your deployments.

### Step 1: Create a Deploy Token or Access Token
It is recommended to use a **Deploy Token** (read-only access to registry) or a **Project Access Token** for Kubernetes.
1.  Go to **Settings** > **Repository** > **Deploy tokens**.
2.  Create a token with `read_registry` scope.
3.  Copy the username and token (password).

### Step 2: Create the Kubernetes Secret
Run the following command in your cluster (replace placeholders):

```bash
kubectl create secret docker-registry gitlab-registry-auth \
  --docker-server=registry.gitlab.com \
  --docker-username=<deploy_token_username> \
  --docker-password=<deploy_token_password> \
  --docker-email=<your_email>
```

### Step 3: Use the Secret in Deployment
Add `imagePullSecrets` to your Kubernetes Pod or Deployment manifest:

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  template:
    spec:
      imagePullSecrets:
        - name: gitlab-registry-auth
      containers:
        - name: my-app-container
          image: registry.gitlab.com/group/project/image:latest
```

## 4. Verifying Images

After a pipeline runs successfully:

1.  Go to your GitLab project.
2.  Navigate to **Deploy** > **Container Registry**.
3.  You should see a list of image repositories (e.g., `apollo11-devsecops/core-api`, `apollo11-devsecops/portal`).
4.  Click on an image name to see the available tags (e.g., `latest`, `short-sha`).

## 5. Pipeline Behavior

The configured `.gitlab-ci.yml` works as follows:

-   **Trigger**: On `push` to `main`, `master`, or feature branches.
-   **Manual Trigger**: You can manually trigger the pipeline from the GitLab UI (**Build** > **Pipelines** > **Run pipeline**). This will force all jobs to run, regardless of code changes.
-   **Conditions**: Only runs jobs for services where code has changed (using `rules:changes`), unless manually triggered.
-   **Tags**:
    -   `latest`: Pushed for every build on all branches.
    -   `<commit-sha>`: Unique tag for every build.
    -   `<branch>-<commit-sha>`: Additional tag for non-default branches.

## Troubleshooting

-   **Pipeline fails with "denied: access forbidden"**: Check that the Container Registry is enabled and your project quota hasn't been exceeded.
-   **Docker-in-Docker issues**: The `dind` service is used. If jobs fail to start docker, check runner configuration (requires privileged mode).
